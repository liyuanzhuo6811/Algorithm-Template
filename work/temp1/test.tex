\documentclass[9pt, a4paper, oneside]{book}
\usepackage{ctex}
\usepackage{authblk}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{titlesec}

\titleformat{\chapter}
{\normalfont\Large\bfseries}{第 \thechapter 部分}{1em}{}

\titleformat{\section}
{\normalfont\Large\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\normalfont\large\bfseries}{\thesubsection}{1em}{}

\titleformat{\subsubsection}
{\normalfont\normalsize\bfseries}{\thesubsubsection}{1em}{}
\geometry{left=3.18cm, right=3.18cm, top=2.54cm, bottom=2.54cm}
\title{\Huge XCPC Template Library}
\author{
    Wu Honglin / real01bit \\
    Li Yuanzhuo / SnowFlavour \\
    Liu Haocheng / lotus\_grass \\
}
\date{最后一次修改：\today}
\newfontfamily\firacode{FiraCode-Regular.ttf}
\lstset{
    language=C++,
    basicstyle=\firacode\small,
    breaklines=true,
    keywordstyle=\bfseries\color{red},
    stringstyle=\color{green}\ttfamily,
    morekeywords={},
    emph={self},
    emphstyle=\bfseries,
    commentstyle=\itshape,
    stringstyle=\bfseries,
    columns=flexible,
    numbers=left,
    numbersep=2em,
    numberstyle=\footnotesize,
    frame=topline,
    framesep=1em
}
\begin{document}
\maketitle
\tableofcontents
\chapter{图论Graph}
\section{connectivity}
\subsection{bcc}
\subsubsection{edge.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
const int N = 5e5 + 10, M = 2e6 + 10;
int n, m, head[N], tot = 1;
struct edge {
    int v, nxt;
    bool is_bridge;
} e[M << 1];
void add(int u, int v) { e[++tot].v = v, e[tot].nxt = head[u], head[u] = tot; }
int dfn[N], low[N], Time;
void tarjan(int u, int edge) {
    dfn[u] = low[u] = ++Time;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (!dfn[v]) {
            tarjan(v, i), low[u] = min(low[u], low[v]);
        } else if (i != (edge ^ 1)) low[u] = min(low[u], dfn[v]);
        if (dfn[u] < low[v]) e[i].is_bridge = e[i ^ 1].is_bridge = true;
    }
}
int dc;
bool in_dcc[N];
vector<int> DCC[N];
void dfs(int u, int dc) {
    in_dcc[u] = true;
    DCC[dc].push_back(u);
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (in_dcc[v] || e[i].is_bridge) continue;
        dfs(v, dc);
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i, 0);
    for (int i = 1; i <= n; i++)
        if (!in_dcc[i]) dfs(i, ++dc);
    cout << dc << "\n";
    for (int i = 1; i <= dc; i++) {
        cout << DCC[i].size() << " ";
        for (auto v : DCC[i]) cout << v << " ";
        cout << "\n";
    }
    return 0;
}\end{lstlisting}
\subsubsection{point.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
const int N = 500005;
const int M = 2000005;
int n, m, head[N], tot;
struct edge {
    int v, nxt;
} e[M << 1];
void add(int u, int v) {
    e[++tot].v = v;
    e[tot].nxt = head[u];
    head[u] = tot;
}
int dfn[N], low[N], Time;
vector<int> dcc[N];
int cnt, stk[N], top;
void tarjan(int u, int rt) {
    dfn[u] = low[u] = ++Time, stk[++top] = u;
    if (u == rt && head[u] == 0) {
        dcc[++cnt].push_back(u);
        return;
    }
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (!dfn[v]) {
            tarjan(v, rt);
            low[u] = min(low[u], low[v]);
            if (dfn[u] <= low[v]) {
                ++cnt;
                do { dcc[cnt].push_back(stk[top--]); } while (stk[top + 1] != v);
                dcc[cnt].push_back(u);
            }
        } else low[u] = min(low[u], dfn[v]);
    }
}
int main() {
    cin.tie(0)->sync_with_stdio(false);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        if (u == v) continue;
        add(u, v);
        add(v, u);
    }
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i, i);
    cout << cnt << "\n";
    for (int i = 1; i <= cnt; i++) {
        cout << dcc[i].size() << " ";
        for (auto x : dcc[i]) cout << x << " ";
        cout << "\n";
    }
    return 0;
}\end{lstlisting}
\subsection{scc}
\subsubsection{kosaraju.cpp}
\begin{lstlisting}[language={C++}]
// g 是原图，g2 是反图
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
vector<vector<int>> g, g2;
vector<int> s;
bool vis[N];
int sccCnt, n, color[N];
void dfs1(int u) {
    vis[u] = true;
    for (int v : g[u])
        if (!vis[v]) dfs1(v);
    s.push_back(u);
}
void dfs2(int u) {
    color[u] = sccCnt;
    for (int v : g2[u])
        if (!color[v]) dfs2(v);
}
void kosaraju() {
    sccCnt = 0;
    for (int i = 1; i <= n; ++i)
        if (!vis[i]) dfs1(i);
    for (int i = n; i >= 1; --i)
        if (!color[s[i]]) {
            ++sccCnt;
            dfs2(s[i]);
        }
}\end{lstlisting}
\subsubsection{tarjan.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
const int N = 10005, M = 100005;
int n, m, head[M], tot;
struct edge {
    int v, nxt;
} e[M];
void add(int u, int v) {
    e[++tot].v = v;
    e[tot].nxt = head[u];
    head[u] = tot;
}
int dfn[N], low[N];
int stk[N], top, Time;
bool ins[N], vis[N];
int fa[N], cnt;
vector<vector<int>> SCC;
void tarjan(int u) {
    dfn[u] = ++Time, low[u] = dfn[u], stk[++top] = u, ins[u] = true;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++cnt;
        SCC.push_back(vector<int>());
        while (stk[top] != u) {
            SCC[cnt].push_back(stk[top]);
            fa[stk[top]] = cnt, ins[stk[top]] = false, top--;
        }
        SCC[cnt].push_back(stk[top]);
        fa[stk[top]] = cnt, ins[stk[top]] = false, top--;
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
    }
    SCC.push_back(vector<int>());
    for (int i = 1; i <= n; i++)
        if (!dfn[i]) tarjan(i);
    cout << cnt << "\n";
    for (int i = 1; i <= cnt; i++) sort(SCC[i].begin(), SCC[i].end());
    for (int i = 1; i <= n; i++) {
        if (vis[fa[i]]) continue;
        else {
            for (auto x : SCC[fa[i]]) cout << x << " ";
            cout << "\n";
            vis[fa[i]] = true;
        }
    }
    return 0;
}\end{lstlisting}
\section{mst}
\subsection{kruscal.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
struct E {
    int u, v, w;
    bool operator<(const E &b) const { return w < b.w; }
} Edge[N];
int f[N];
int getf(int x) { return f[x] == x ? x : f[x] = getf(f[x]); }
vector<int> tr[N];
int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) f[i] = i;
    for (int i = 1; i <= m; i++) cin >> Edge[i].u >> Edge[i].v >> Edge[i].w;
    sort(Edge + 1, Edge + 1 + m);
    for (int i = 1; i <= m; i++) {
        int fu = getf(Edge[i].u), fv = getf(Edge[i].v);
        if (fu == fv) continue;
        tr[Edge[i].u].push_back(Edge[i].v);
        tr[Edge[i].v].push_back(Edge[i].u);
    }
    return 0;
}\end{lstlisting}
\subsection{prim.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
constexpr int N = 5050, M = 2e5 + 10;
struct E {
    int v, w, x;
} e[M * 2];
int n, m, h[N], cnte;
void adde(int u, int v, int w) { e[++cnte] = E{v, w, h[u]}, h[u] = cnte; }
struct S {
    int u, d;
};
bool operator<(const S &x, const S &y) { return x.d > y.d; }
priority_queue<S> q;
int dis[N];
bool vis[N];
int res = 0, cnt = 0;
void Prim() {
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    q.push({1, 0});
    while (!q.empty()) {
        if (cnt >= n) break;
        int u = q.top().u, d = q.top().d;
        q.pop();
        if (vis[u]) continue;
        vis[u] = true;
        ++cnt;
        res += d;
        for (int i = h[u]; i; i = e[i].x) {
            int v = e[i].v, w = e[i].w;
            if (w < dis[v]) { dis[v] = w, q.push({v, w}); }
        }
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; ++i) { cin >> u >> v >> w, adde(u, v, w), adde(v, u, w); }
    Prim();
    if (cnt == n) cout << res;
    else cout << "No MST.";
    return 0;
}\end{lstlisting}
\section{shortest-path}
\subsection{dijkstra.cpp}
\begin{lstlisting}[language={C++}]
struct edge {
    int v, w;
};
struct node {
    int dis, u;
    bool operator>(const node &a) const { return dis > a.dis; }
};
vector<edge> e[MAXN];
int dis[MAXN], vis[MAXN];
priority_queue<node, vector<node>, greater<node>> q;
void dijkstra(int n, int s) {
    memset(dis, 0x3f, (n + 1) * sizeof(int));
    memset(vis, 0, (n + 1) * sizeof(int));
    dis[s] = 0;
    q.push({0, s});
    while (!q.empty()) {
        int u = q.top().u;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}\end{lstlisting}
\subsection{spfa.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, m;
vector<pair<int, int>> g[N];
inline void add(int u, int v, int w) { g[u].push_back({v, w}); }
queue<int> q;
int dis[N];
bool inq[N];
inline void spfa(int s) {
    memset(dis, 0x3f, sizeof(dis));
    memset(inq, false, sizeof(inq));
    inq[s] = true, dis[s] = 0;
    q.push(s);
    while (q.size()) {
        int u = q.front();
        q.pop(), inq[u] = false;
        for (auto [v, w] : g[u])
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!inq[v]) q.push(v);
            }
    }
}
int main() {
    cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; i++) cin >> u >> v >> w, add(u, v, w), add(v, u, w);
    spfa(1);
    return 0;
}\end{lstlisting}
\section{tree}
\subsection{centroid.cpp}
\begin{lstlisting}[language={C++}]
int size[MAXN], weight[MAXN], centroid[2];
void GetCentroid(int cur, int fa) {
    size[cur] = 1, weight[cur] = 0;
    for (int i = head[cur]; i != -1; i = e[i].nxt) {
        if (e[i].to != fa) {
            GetCentroid(e[i].to, cur);
            size[cur] += size[e[i].to];
            weight[cur] = max(weight[cur], size[e[i].to]);
        }
    }
    weight[cur] = max(weight[cur], n - size[cur]);
    if (weight[cur] <= n / 2) centroid[centroid[0] != 0] = cur;
}\end{lstlisting}
\subsection{diameter.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
constexpr int N = 10000 + 10;
int n, c, d[N];
vector<int> E[N];
void dfs(int u, int fa) {
    for (int v : E[u]) {
        if (v == fa) continue;
        d[v] = d[u] + 1;
        if (d[v] > d[c]) c = v;
        dfs(v, u);
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        E[u].push_back(v), E[v].push_back(u);
    }
    dfs(1, 0);
    d[c] = 0, dfs(c, 0);
    printf("%d\n", d[c]);
    return 0;
}\end{lstlisting}
\subsection{hld.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namepace std;
const int N = 1e5 + 5;
int n;
vector<int> g[N];
int fa[N], dep[N], siz[N], hson[N], dfn[N], idx, top[N];
void hld1(int u, int fath) {
    fa[u] = fath, dep[u] = dep[fath] + 1, siz[u] = 1;
    for (int v : g[u]) {
        if (v == fath) continue;
        hld1(v, u), siz[u] += siz[v];
        if (siz[v] > siz[hson[u]]) hson[u] = v;
    }
}
void hld2(int u, int nowtp) {
    top[u] = nowtp, dfn[u] = ++idx;
    if (hson[u]) hld2(hson[u], nowtp);
    for (int v : g[u])
        if (v != fa[u] && v != hson[u]) hld2(v, v);
}
inline int LCA(int x, int y) {
    while (top[x] != top[y]) return dep[top[x]] < dep[top[y]] ? y = fa[top[y]] : x = fa[top[x]];
    return dep[x] < dep[y] ? x : y;
}
int main() { return 0; }\end{lstlisting}
\subsection{virtual-tree.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, q, m, h[N], s[N], cnt;
vector<int> g[N], vt[N];
int fa[N], dep[N], siz[N], hson[N], dfn[N], top[N], idx;
void hld1(int u, int fath) { ... }
void hld2(int u, int fath) { ... }
int lca(int u, int v) { ... } // 重链剖分相关内容见 oi-algorithms/graph/tree/hld.cpp
bool cmp(int a, int b) { return dfn[a] < dfn[b]; }
inline void buildVtree() {
    sort(h + 1, h + 1 + m, cmp);
    s[cnt = 1] = 1;
    for (int i = 1; i <= m; i++) s[++cnt] = h[i], s[++cnt] = lca(h[i], h[i + 1]);
    s[++cnt] = h[m];
    sort(s + 1, s + 1 + cnt, cmp);
    cnt = unique(s + 1, s + 1 + cnt) - s - 1;
    for (int i = 1; i <= cnt; i++) vt[lca(s[i], s[i + 1])].push_back(s[i + 1]);
}
int main() { return 0; }\end{lstlisting}
\section{diff-constraints.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
struct edge {
    int v, w, next;
} e[40005];
int head[10005], vis[10005], tot[10005], cnt;
long long ans, dist[10005];
queue<int> q;
void addedge(int u, int v, int w) { // 加边
    e[++cnt].v = v;
    e[cnt].w = w;
    e[cnt].next = head[u];
    head[u] = cnt;
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int op, x, y, z;
        cin >> op;
        if (op == 1) {
            cin >> x >> y >> z;
            addedge(y, x, z);
        } else if (op == 2) {
            cin >> x >> y >> z;
            addedge(x, y, -z);
        } else {
            cin >> x >> y;
            addedge(x, y, 0);
            addedge(y, x, 0);
        }
    }
    for (int i = 1; i <= n; i++) addedge(0, i, 0);
    memset(dist, -0x3f, sizeof(dist));
    dist[0] = 0;
    vis[0] = 1;
    q.push(0);
    while (!q.empty()) { // 判负环，看上面的
        int cur = q.front();
        q.pop();
        vis[cur] = 0;
        for (int i = head[cur]; i; i = e[i].next)
            if (dist[cur] + e[i].w > dist[e[i].v]) {
                dist[e[i].v] = dist[cur] + e[i].w;
                if (!vis[e[i].v]) {
                    vis[e[i].v] = 1;
                    q.push(e[i].v);
                    tot[e[i].v]++;
                    if (tot[e[i].v] >= n) {
                        cout << "No\n";
                        return 0;
                    }
                }
            }
    }
    cout << "Yes\n";
    return 0;
}\end{lstlisting}
\chapter{字符串String}
\section{hash}
\subsection{double-valued.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
using std::string;
using ull = unsigned long long;
ull base = 131, mod1 = 212370440130137957, mod2 = 1e9 + 7;
ull get_hash1(string s) {
    int len = s.size();
    ull ans = 0;
    for (int i = 0; i < len; i++) ans = (ans * base + (ull)s[i]) % mod1;
    return ans;
}
ull get_hash2(string s) {
    int len = s.size();
    ull ans = 0;
    for (int i = 0; i < len; i++) ans = (ans * base + (ull)s[i]) % mod2;
    return ans;
}
bool cmp(const string s, const string t) {
    bool f1 = get_hash1(s) != get_hash1(t);
    bool f2 = get_hash2(s) != get_hash2(t);
    return f1 || f2;
}
int main() { return 0; }\end{lstlisting}
\subsection{modular.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
using std::string;
constexpr int M = 1e9 + 7;
constexpr int B = 233;
using ll = long long;
int get_hash(const string &s) {
    int res = 0;
    for (int i = 0; i < s.size(); ++i) { res = ((ll)res * B + s[i]) % M; }
    return res;
}
bool cmp(const string &s, const string &t) { return get_hash(s) == get_hash(t); }
int main() { return 0; }\end{lstlisting}
\section{SA}
\subsection{DC3.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
#define f(x) (x / 3) + (x % 3 == 1 ? 0 : cd)          // f(x) 表示原串中后缀 x 在新串中的位置
#define g(x) (x >= cd ? (x - cd) * 3 + 2 : x * 3 + 1) // g(x) 表示新串后缀 x  在原串中的位置
using namespace std;
const int N = 1e6 + 5;
string s;
int n, sa[N * 3 + 100], rk[N * 3 + 100], buc[N], x[N], y[N], height[N];
void sort(int *rk, int *a, int *b, int n, int Sigma) // rk 表示待排序串, a 表示指标集, b 表示排序后的指标顺序
{
    for (int i = 0; i <= Sigma; i++) buc[i] = 0;
    for (int i = 0; i < n; i++) buc[rk[a[i]]]++;
    for (int i = 1; i <= Sigma; i++) buc[i] += buc[i - 1];
    for (int i = n - 1; i >= 0; i--) b[--buc[rk[a[i]]]] = a[i];
}
bool cmp3(int *r, int x, int y) { return r[x] == r[y] && r[x + 1] == r[y + 1] && r[x + 2] == r[y + 2]; }
bool cmps(int *r, int x, int y) {
    if (r[x] != r[y]) return r[x] < r[y];
    if (x % 3 == 1) return buc[x + 1] < buc[y + 1];
    return !cmps(r, y + 1, x + 1);
}
void DC3(int *rk, int *sa, int n, int Sigma) {
    bool h = (n % 3 == 1);
    if (h) rk[n++] = 0;
    int *nrk = rk + n + 2, *nsa = sa + n, cb = 0, p; // nrk, nsa 分别表示新的 rk 和 sa, cb 表示 B 类后缀的数量
    for (int i = 0; i < n; i++)
        if (i % 3) x[cb++] = i;
    rk[n] = rk[n + 1] = 0;
    sort(rk + 2, x, y, cb, Sigma), sort(rk + 1, y, x, cb, Sigma), sort(rk, x, y, cb, Sigma); // 指标顺序存在了 y 中
    int ca = 0, cd = (n + 1) / 3; // ca 表示 A 类后缀的数量，cd 表示 i % 3 = 1 的后缀的数量
    nrk[f(y[0])] = p = 1;
    for (int i = 1; i < cb; i++) {
        if (!cmp3(rk, y[i], y[i - 1])) p++;
        nrk[f(y[i])] = p;
    }
    if (p < cb) DC3(nrk, nsa, cb, p); // 递归求解 B 类后缀
    else
        for (int i = 0; i < cb; i++)
            if (nrk[i]) nsa[nrk[i] - 1] = i;
    for (int i = 0; i < cb; i++)
        if (nsa[i] < cd) y[ca++] = 3 * nsa[i];
    sort(rk, y, x, ca, Sigma);
    for (int i = 0; i < cb; i++) buc[y[i] = g(nsa[i])] = i; // 利用 buc 存 B 类后缀的排名
    buc[n] = -1, p = 0;
    int i = 0, j = h;
    while (i < ca && j < cb) {
        if (cmps(rk, y[j], x[i])) sa[p++] = y[j++];
        else sa[p++] = x[i++];
    }
    while (i < ca) sa[p++] = x[i++];
    while (j < cb) sa[p++] = y[j++];
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    cout.tie(nullptr);
    cin >> s;
    n = s.length();
    for (int i = 0; i < n; i++) rk[i] = s[i] - '0' + 1;
    DC3(rk, sa, n, 75);
    for (int i = 0; i < n; i++) cout << sa[i] + 1 << ' ';
    cout << '\n';
    for (int i = 0; i < n; i++) rk[sa[i]] = i;
    for (int i = 0, k = 0; i < n; i++) {
        if (!rk[i]) continue;
        if (k) --k;
        while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k;
        height[rk[i]] = k;
    }
    for (int i = 1; i < n; i++) cout << height[i] << ' ';
    return cout << '\n', 0;
}\end{lstlisting}
\subsection{SA-IS.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <cstdio>
using namespace std;
const int N = 1e6 + 10;
typedef long long ll;
template <typename T> inline void gm(T *&bas, int siz, T *&op) { op = bas, bas += siz; }
#define pus(x) (sa[cur[a[x]]--] = x)
#define pul(x) (sa[cur[a[x]]++] = x)
#define inds(lms)                                                                                                      \
    for (int i = 1; i <= n; i++) sa[i] = -1;                                                                           \
    for (int i = 1; i <= n; i++) sum[i] = 0;                                                                           \
    for (int i = 1; i <= n; i++) sum[a[i]]++;                                                                          \
    for (int i = 1; i <= n; i++) sum[i] += sum[i - 1];                                                                 \
    for (int i = 1; i <= n; i++) cur[i] = sum[i];                                                                      \
    for (int i = m; i >= 1; i--) pus(lms[i]);                                                                          \
    for (int i = 1; i <= n; i++) cur[i] = sum[i - 1] + 1;                                                              \
    for (int i = 1; i <= n; i++)                                                                                       \
        if (sa[i] > 1 && !tp[sa[i] - 1]) pul(sa[i] - 1);                                                               \
    for (int i = 1; i <= n; i++) cur[i] = sum[i];                                                                      \
    for (int i = n; i >= 1; i--)                                                                                       \
        if (sa[i] > 1 && tp[sa[i] - 1]) pus(sa[i] - 1);
int sa[N], sum[N], cur[N], rk[N], A_bas[N << 4], *A_t;
inline void sais(int n, int *a) {
    int *tp, *p;
    gm(A_t, n + 1, tp), gm(A_t, n + 2, p);
    tp[n] = 1;
    for (int i = n - 1; i >= 1; i--) tp[i] = (a[i] == a[i + 1]) ? tp[i + 1] : (a[i] < a[i + 1]);
    int m = 0;
    for (int i = 1; i <= n; i++) rk[i] = (tp[i] && !tp[i - 1]) ? (p[++m] = i, m) : -1;
    inds(p);
    int tot = 0, *a1;
    gm(A_t, m + 1, a1);
    p[m + 1] = n;
    for (int i = 1, x, y; i <= n; i++)
        if ((x = rk[sa[i]]) != -1) {
            if (tot == 0 || p[x + 1] - p[x] != p[y + 1] - p[y]) tot++;
            else
                for (int p1 = p[x], p2 = p[y]; p2 <= p[y + 1]; p1++, p2++)
                    if ((a[p1] << 1 | tp[p1]) != (a[p2] << 1 | tp[p2])) {
                        tot++;
                        break;
                    }
            a1[y = x] = tot;
        }
    if (tot == m)
        for (int i = 1; i <= m; i++) sa[a1[i]] = i;
    else sais(m, a1);
    for (int i = 1; i <= m; i++) a1[i] = p[sa[i]];
    inds(a1);
}
char mde[N];
int n;
int a[N];
int tr[300];
char buf[20];
int cnt;
int main() {
    A_t = A_bas;
    scanf("%s", mde + 1);
    while (mde[n + 1] != '\0') n++;
    for (int i = 1; i <= n; i++) tr[mde[i]] = 1;
    for (int i = 1; i < 300; i++) tr[i] += tr[i - 1];
    for (int i = 1; i <= n; i++) a[i] = tr[mde[i]] + 1;
    a[++n] = 1;
    sais(n, a);
    for (int i = 2; i <= n; i++) {
        int tmp = sa[i];
        while (tmp) buf[++cnt] = tmp % 10 + 48, tmp /= 10;
        while (cnt) putchar(buf[cnt--]);
        putchar(' ');
    }
    return 0;
}\end{lstlisting}
\section{trie}
\subsection{persistent-trie.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
const int N = 6e5 + 5, H = 28;
int n, m, a[N], s[N], rt[N], ch[N * 33][2], cnt[N * 33], tot;
void Insert(int u, int pre, int x) {
    for (int i = H; i >= 0; i--) {
        cnt[u] = cnt[pre] + 1;
        int c = ((x & (1 << i)) ? 1 : 0);
        if (!ch[u][c]) ch[u][c] = ++tot;
        ch[u][c ^ 1] = ch[pre][c ^ 1];
        u = ch[u][c], pre = ch[pre][c];
    }
    cnt[u] = cnt[pre] + 1;
}
int query(int u, int v, int x) {
    int res = 0;
    for (int i = H; i >= 0; i--) {
        int c = ((x & (1 << i)) ? 1 : 0);
        if (cnt[ch[u][!c]] - cnt[ch[v][!c]]) u = ch[u][!c], v = ch[v][!c], res += (1 << i);
        else u = ch[u][c], v = ch[v][c];
    }
    return res;
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    cout.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, x; i <= n; i++) cin >> a[i], s[i] = s[i - 1] ^ a[i];
    for (int i = 1; i <= n; i++) rt[i] = ++tot, Insert(rt[i], rt[i - 1], s[i]);
    char op;
    for (int l, r, val; m; m--) {
        cin >> op;
        if (op == 'A') {
            n++, cin >> a[n];
            s[n] = s[n - 1] ^ a[n], rt[n] = ++tot;
            Insert(rt[n], rt[n - 1], s[n]);
        }
        if (op == 'Q') {
            cin >> l >> r >> val;
            l--, r--;
            if (!l) cout << max(s[n] ^ val, query(rt[r], rt[0], s[n] ^ val)) << '\n';
            else cout << query(rt[r], rt[l - 1], s[n] ^ val) << '\n';
        }
    }
    return 0;
}\end{lstlisting}
\subsection{trie.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
using namespace std;
struct trie {
    int son[100000][26], cnt;
    bool exist[100000];
    void insert(char *s, int l) {
        int p = 0;
        for (int i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!son[p][c]) son[p][c] = ++cnt;
            p = son[p][c];
        }
        exist[p] = true;
    }
    bool find(char *s, int l) {
        int p = 0;
        for (int i = 0; i < l; i++) {
            int c = s[i] - 'a';
            if (!son[p][c]) return 0;
            p = son[p][c];
        }
        return exist[p];
    }
};
int main() { return 0; }\end{lstlisting}
\section{acam.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
namespace acam {
const int SIZ = 2000005;
struct node {
    int ch[26], fail, ans, id;
    node() { memset(ch, 0, sizeof(ch)), ans = id = 0; }
    inline int &operator[](const int x) { return x < 26 ? ch[x] : ch[x - 'a']; }
    inline int operator[](const int x) const { return x < 26 ? ch[x] : ch[x - 'a']; }
} tr[SIZ];
int tot, ans[SIZ], pcnt;
vector<int> fail[SIZ];
inline void insert(char *s, int &id) {
    int u = 0;
    for (int i = 1; s[i]; i++) {
        if (!tr[u][i]) tr[u][i] = ++tot;
        u = tr[u][i];
    }
    if (!tr[u].id) tr[u].id = ++pcnt;
    id = tr[u].id;
}
inline void build() {
    queue<int> q;
    for (int i = 0; i < 26; i++)
        if (tr[0][i]) q.push(tr[0][i]), fail[0].push_back(tr[0][i]);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; i++) {
            if (tr[u][i]) {
                tr[tr[u][i]].fail = tr[tr[u].fail][i];
                fail[tr[tr[u].fail][i]].push_back(tr[u][i]);
                q.push(tr[u][i]);
            } else tr[u][i] = tr[tr[u].fail][i];
        }
    }
}
void query(char *t) {
    int u = 0;
    for (int i = 1; t[i]; ++i) u = tr[u][t[i]], tr[u].ans++;
}
void dfs(int u) {
    for (int v : fail[u]) {
        dfs(v);
        tr[u].ans += tr[v].ans;
    }
    ans[tr[u].id] = tr[u].ans;
}
}; // namespace acam
int main() { return 0; }\end{lstlisting}
\section{kmp.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
vector<int> pf(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j && s[j] != s[i]) j = pi[j - 1];
        if (s[i] == s[j]) ++j;
        pi[i] = j;
    }
    return pi;
}
int main() { return 0; }\end{lstlisting}
\section{manacher.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
using namespace std;
const int N = 2.2e7 + 10;
inline bool chk(char c) { return c >= 'a' && c <= 'z'; }
int n, f[N];
char s[N], c;
int main() {
    s[0] = '~';
    while (chk(c = getchar())) s[++n] = '|', s[++n] = c;
    s[++n] = '|';
    for (int i = 1, maxr = 0, mid = 0; i <= n; i++) {
        if (i < maxr) f[i] = min(f[2 * mid - i], maxr - i);
        for (int j = i + f[i] + 1; j <= n; j++) {
            if (s[j] == s[2 * i - j]) ++f[i];
            else break;
        }
        if (i + f[i] > maxr) maxr = i + f[i], mid = i;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++)
        if (f[i] > ans) ans = f[i];
    cout << ans;
    return 0;
}\end{lstlisting}
\section{z-func.cpp}
\begin{lstlisting}[language={C++}]
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        if (i <= r && z[i - l] < r - i + 1) z[i] = z[i - l];
        else {
            z[i] = r - i + 1;
            while (i + z[i] < n && s[i + z[i]] == s[z[i]]) ++z[i];
        }
        if (i + z[i] - 1 > r) r = i + z[i] - 1, l = i;
    }
    return z;
}
int main() { return 0; }\end{lstlisting}
\chapter{数学Math}
\section{lineral-algebra}
\subsection{mat.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
struct mat {
    LL a[sz][sz];
    mat() { memset(a, 0, sizeof a); }
    mat operator-(const mat &T) const {
        mat res;
        for (int i = 0; i < sz; ++i)
            for (int j = 0; j < sz; ++j) res.a[i][j] = (a[i][j] - T.a[i][j]) % MOD;
        return res;
    }
    mat operator+(const mat &T) const {
        mat res;
        for (int i = 0; i < sz; ++i)
            for (int j = 0; j < sz; ++j) res.a[i][j] = (a[i][j] + T.a[i][j]) % MOD;
        return res;
    }
    mat operator*(const mat &T) const {
        mat res;
        int r;
        for (int i = 0; i < sz; ++i)
            for (int k = 0; k < sz; ++k) {
                r = a[i][k];
                for (int j = 0; j < sz; ++j) res.a[i][j] += T.a[k][j] * r, res.a[i][j] %= MOD;
            }
        return res;
    }

    mat operator^(LL x) const {
        mat res, bas;
        for (int i = 0; i < sz; ++i) res.a[i][i] = 1;
        for (int i = 0; i < sz; ++i)
            for (int j = 0; j < sz; ++j) bas.a[i][j] = a[i][j] % MOD;
        while (x) {
            if (x & 1) res = res * bas;
            bas = bas * bas;
            x >>= 1;
        }
        return res;
    }
};
int main() { return 0; }\end{lstlisting}
\section{lineral-programming}
\subsection{simpex.cpp}
\begin{lstlisting}[language={C++}]
#include <cmath>
#include <cstring>
#include <iostream>
using namespace std;
constexpr int M = 10005, N = 1005, INF = 1e9;
int n, m;
double a[M][N], b[M], c[N], v;
void pivot(int l, int e) { // 转轴操作函数
    b[l] /= a[l][e];
    for (int j = 1; j <= n; j++)
        if (j != e) a[l][j] /= a[l][e];
    a[l][e] = 1 / a[l][e];

    for (int i = 1; i <= m; i++)
        if (i != l && fabs(a[i][e]) > 0) {
            b[i] -= a[i][e] * b[l];
            for (int j = 1; j <= n; j++)
                if (j != e) a[i][j] -= a[i][e] * a[l][j];
            a[i][e] = -a[i][e] * a[l][e];
        }
    v += c[e] * b[l];
    for (int j = 1; j <= n; j++)
        if (j != e) c[j] -= c[e] * a[l][j];
    c[e] = -c[e] * a[l][e];
}
double simplex() {
    while (true) {
        int e = 0, l = 0;
        for (e = 1; e <= n; e++)
            if (c[e] > (double)0) break;
        if (e == n + 1) return v; // 此时v即为最优解
        double mn = INF;
        for (int i = 1; i <= m; i++) {
            if (a[i][e] > (double)0 && mn > b[i] / a[i][e]) {
                mn = b[i] / a[i][e]; // 找对这个e限制最紧的l
                l = i;
            }
        }
        if (mn == INF) return INF; // unbounded
        pivot(l, e);               // 转动l,e
    }
}
int main() {
    cin.tie(nullptr)->sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> c[i];
    for (int i = 1; i <= m; i++) {
        int s, t;
        cin >> s >> t;
        for (int j = s; j <= t; j++) a[i][j] = 1; // 表示第i种志愿者在j时间可以服务
        cin >> b[i];
    }
    cout << (int)(simplex() + 0.5);
}\end{lstlisting}
\section{number-theory}
\subsection{euler}
\subsubsection{theorem}
\subsubsection{get-euler.cpp}
\begin{lstlisting}[language={C++}]
#include <cmath>
int euler_phi(int n) {
    int ans = n;
    for (int i = 2; i * i <= n; i++)
        if (n % i == 0) {
            ans = ans / i * (i - 1);
            while (n % i == 0) n /= i;
        }
    if (n > 1) ans = ans / n * (n - 1);
    return ans;
}
int main() { return 0; }\end{lstlisting}
\subsubsection{sieve.cpp}
\begin{lstlisting}[language={C++}]
#include <bitset>
#include <iostream>
#include <vector>
using std::bitset;
using std::vector;
const int N = 1e7 + 5;
bitset<N> not_prime;
int prime[N], pcnt, phi[N];
inline void sieve(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!not_prime[i]) prime[++pcnt] = i, phi[i] = i - 1;
        for (int j = 1; j <= pcnt && i * prime[j] <= n; j++) {
            not_prime[i * prime[j]] = true;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
}
int main() { return 0; }\end{lstlisting}
\subsection{lucas}
\subsubsection{ex-lucas.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
#include <vector>

// Extended Euclid.
void ex_gcd(int a, int b, int &x, int &y) {
    if (!b) x = 1, y = 0;
    else ex_gcd(b, a % b, y, x), y -= a / b * x;
}

// Inverse of a mod m.
int inverse(int a, int m) {
    int x, y;
    ex_gcd(a, m, x, y);
    return (x % m + m) % m;
}

// Coefficient in CRT.
int crt_coeff(int m_i, int m) {
    long long mm = m / m_i;
    mm *= inverse(mm, m_i);
    return mm % m;
}

// Binominal Coefficient Calculator Modulo Prime Power.
class BinomModPrimePower {
    int p, a, pa;
    std::vector<int> f;

    // Obtain multiplicity of p in n!.
    long long nu(long long n) {
        long long count = 0;
        do {
            n /= p;
            count += n;
        } while (n);
        return count;
    }

    // Calculate (n!)_p mod pa.
    long long fact_mod(long long n) {
        bool neg = p != 2 || pa <= 4;
        long long res = 1;
        while (n > 1) {
            if ((n / pa) & neg) res = pa - res;
            res = res * f[n % pa] % pa;
            n /= p;
        }
        return res;
    }

  public:
    BinomModPrimePower(int p, int a, int pa) : p(p), a(a), pa(pa), f(pa) {
        // Pretreatment.
        f[0] = 1;
        for (int i = 1; i < pa; ++i) { f[i] = i % p ? (long long)f[i - 1] * i % pa : f[i - 1]; }
    }

    // Calculate Binom(n, k) mod pa.
    int binomial(long long n, long long k) {
        long long v = nu(n) - nu(n - k) - nu(k);
        if (v >= a) return 0;
        auto res = fact_mod(n - k) * fact_mod(k) % pa;
        res = fact_mod(n) * inverse(res, pa) % pa;
        for (; v; --v) res *= p;
        return res % pa;
    }
};

// Binominal Coefficient Calculator.
class BinomMod {
    int m;
    std::vector<BinomModPrimePower> bp;
    std::vector<long long> crt_m;

  public:
    BinomMod(int n) : m(n) {
        // Factorize.
        for (int p = 2; p * p <= n; ++p) {
            if (n % p == 0) {
                int a = 0, pa = 1;
                for (; n % p == 0; n /= p, ++a, pa *= p);
                bp.emplace_back(p, a, pa);
                crt_m.emplace_back(crt_coeff(pa, m));
            }
        }
        if (n > 1) {
            bp.emplace_back(n, 1, n);
            crt_m.emplace_back(crt_coeff(n, m));
        }
    }

    // Calculate Binom(n, k) mod m.
    int binomial(long long n, long long k) {
        long long res = 0;
        for (size_t i = 0; i != bp.size(); ++i) { res = (bp[i].binomial(n, k) * crt_m[i] + res) % m; }
        return res;
    }
};

int main() {
    int t, m;
    std::cin >> t >> m;
    BinomMod bm(m);
    for (; t; --t) {
        long long n, k;
        std::cin >> n >> k;
        std::cout << bm.binomial(n, k) << '\n';
    }
    return 0;
}\end{lstlisting}
\subsubsection{lucas.cpp}
\begin{lstlisting}[language={C++}]
long long Lucas(long long n, long long k, long long p) {
    if (k == 0) return 1;
    return (C(n % p, k % p, p) * Lucas(n / p, k / p, p)) % p;
}\end{lstlisting}
\subsection{mobius}
\subsubsection{sieve.cpp}
\begin{lstlisting}[language={C++}]
#include <bitset>
#include <iostream>
#include <vector>
using std::bitset;
using std::vector;
using ll = long long;
const int N = 1e7 + 5;
bitset<N> not_prime;
vector<int> pr;
int mu[N];
inline void sieve(int n) {
    mu[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!not_prime[i]) mu[i] = -1, pr.push_back(i);
        for (int x : pr) {
            if (i * x > n) break;
            not_prime[i * x] = true;
            if (i % x == 0) break;
            mu[i * x] = -mu[i];
        }
    }
}
int main() { return 0; }\end{lstlisting}
\subsection{prime}
\subsubsection{miller-rabin.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
bool millerRabin(int n) {
    if (n < 3 || n % 2 == 0) return n == 2;
    if (n % 3 == 0) return n == 3;
    int u = n - 1, t = 0;
    while (u % 2 == 0) u /= 2, ++t;
    // test_time 为测试次数，建议设为不小于 8
    // 的整数以保证正确率，但也不宜过大，否则会影响效率
    for (int i = 0; i < test_time; ++i) {
        // 0, 1, n-1 可以直接通过测试, a 取值范围 [2, n-2]
        int a = rand() % (n - 3) + 2, v = quickPow(a, u, n);
        if (v == 1) continue;
        int s;
        for (s = 0; s < t; ++s) {
            if (v == n - 1) break; // 得到平凡平方根 n-1，通过此轮测试
            v = (long long)v * v % n;
        }
        // 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t
        // 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1
        if (s == t) return 0;
    }
    return 1;
}
int main() { return 0; }\end{lstlisting}
\subsubsection{sieve.cpp}
\begin{lstlisting}[language={C++}]
#include <bitset>
#include <iostream>
#include <vector>
using std::bitset;
using std::vector;
const int N = 1e7 + 5;
bitset<N> not_prime;
vector<int> sieve(int n) {
    vector<int> prime;
    for (int i = 2; i <= n; i++) {
        if (!not_prime[i]) prime.emplace_back(i);
        for (int x : prime) {
            if (x * i > n) break;
            not_prime[x * i] = true;
            if (i % x == 0) break;
        }
    }
    return prime;
}
int main() { return 0; }\end{lstlisting}
\subsection{crt.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
using LL = long long;
LL ex_gcd(LL a, LL b, LL &x, LL &y) {
    if (!b) return x = 1, y = 0, a;
    LL g = ex_gcd(b, a % b, x, y), t = x;
    x = y, y = t - (a / b) * y;
    return g;
}
LL CRT(int k, LL *a, LL *r) {
    LL n = 1, ans = 0;
    for (int i = 1; i <= k; i++) n = n * r[i];
    for (int i = 1; i <= k; i++) {
        LL m = n / r[i], b, y;
        ex_gcd(m, r[i], b, y); // b * m mod r[i] = 1
        ans = (ans + a[i] * m * b % n) % n;
    }
    return (ans % n + n) % n;
}
int main() { return 0; }\end{lstlisting}
\subsection{du.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <iostream>
#include <map>
#define int long long
using namespace std;
const int N = 2000005;
int p[N], mu[N], sum[N], cnt;
bool flg[N];
map<int, int> mp;
void init(int n) {
    mu[1] = 1ll;
    for (int i = 2; i <= n; i++) {
        if (!flg[i]) p[++cnt] = i, mu[i] = -1;
        for (int j = 1; j <= cnt && i * p[j] <= n; j++) {
            flg[i * p[j]] = true;
            if (i % p[j] == 0) {
                mu[i * p[j]] = 0;
                break;
            }
            mu[i * p[j]] = -mu[i];
        }
    }
    for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + mu[i];
}
int sum_mu(int n) {
    if (n < N) return sum[n];
    if (mp.find(n) != mp.end()) return mp[n];
    int res = 1ll;
    for (int i = 2, j; i <= n; i = j + 1) {
        j = n / (n / i);
        res -= sum_mu(n / i) * (j - i + 1);
    }
    return mp[n] = res;
}
int sum_phi(int n) {
    int res = 0ll;
    for (int i = 1, j; i <= n; i = j + 1) {
        j = n / (n / i);
        res += (sum_mu(j) - sum_mu(i - 1)) * (n / i) * (n / i);
    }
    return (res - 1) / 2 + 1;
}
signed main() {
    cin.tie(0)->sync_with_stdio(false);
    cout.tie(0);
    init(N - 1);
    int T, n;
    cin >> T;
    while (T--) {
        cin >> n;
        cout << sum_phi(n) << " " << sum_mu(n) << "\n";
    }
    return 0;
}\end{lstlisting}
\subsection{exgcd.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }
int ex_gcd(int a, int b, int &x, int &y) {
    if (!b) return x = 1, y = 0, a;
    int g = ex_gcd(b, a % b, x, y), t = x;
    x = y, y = t - (a / b) * y;
    return g;
}
int main() { return 0; }\end{lstlisting}
\subsection{pollard-rho.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;
using ll = long long;
using ull = unsigned long long;
int t;
ll max_factor, n;
ll gcd(ll a, ll b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
ll bmul(ll a, ll b, ll m) { // 快速乘
    ull c = (ull)a * (ull)b - (ull)((long double)a / m * b + 0.5L) * (ull)m;
    if (c < (ull)m) return c;
    return c + m;
}
ll qpow(ll x, ll p, ll mod) { // 快速幂
    ll ans = 1;
    while (p) {
        if (p & 1) ans = bmul(ans, x, mod);
        x = bmul(x, x, mod);
        p >>= 1;
    }
    return ans;
}
bool Miller_Rabin(ll p) { // 判断素数
    if (p < 2) return false;
    if (p == 2) return true;
    if (p == 3) return true;
    ll d = p - 1, r = 0;
    while (!(d & 1)) ++r, d >>= 1; // 将d处理为奇数
    for (ll k = 0; k < 10; ++k) {
        ll a = rand() % (p - 2) + 2;
        ll x = qpow(a, d, p);
        if (x == 1 || x == p - 1) continue;
        for (int i = 0; i < r - 1; ++i) {
            x = bmul(x, x, p);
            if (x == p - 1) break;
        }
        if (x != p - 1) return false;
    }
    return true;
}
ll Pollard_Rho(ll x) {
    ll s = 0, t = 0;
    ll c = (ll)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    ll val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) { // 倍增优化
        for (step = 1; step <= goal; ++step) {
            t = (bmul(t, t, x) + c) % x;
            val = bmul(val, abs(t - s), x);
            if ((step % 127) == 0) {
                ll d = gcd(val, x);
                if (d > 1) return d;
            }
        }
        ll d = gcd(val, x);
        if (d > 1) return d;
    }
}
void fac(ll x) {
    if (x <= max_factor || x < 2) return;
    if (Miller_Rabin(x)) {               // 如果x为质数
        max_factor = max(max_factor, x); // 更新答案
        return;
    }
    ll p = x;
    while (p >= x) p = Pollard_Rho(x); // 使用该算法
    while ((x % p) == 0) x /= p;
    fac(x), fac(p); // 继续向下分解x和p
}
int main() {
    cin >> t;
    while (t--) {
        srand((unsigned)time(NULL));
        max_factor = 0;
        cin >> n;
        fac(n);
        if (max_factor == n) cout << "Prime\n";
        else cout << max_factor << '\n';
    }
    return 0;
}\end{lstlisting}
\subsection{sqrt-decomposition.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
using ll = long long;
ll get_sum(int l, int r) { return r - l + 1; }
ll calc(int n) {
    ll res = 0;
    for (int l = 1, r = 0; l <= n; l = r + 1) {
        r = n / (n / l);
        res += get_sum(l, r);
    }
    return res;
}
int main() { return 0; }\end{lstlisting}
\section{poly}
\subsection{fft}
\subsubsection{divide-and-conquer.cpp}
\begin{lstlisting}[language={C++}]
#include <cmath>
#include <cstdio>
#define MAXN 4000005
using namespace std;
int n, m;
const double PI = acos(-1.0);
struct CP {
    CP(double xx = 0, double yy = 0) { x = xx, y = yy; }
    double x, y;
    CP operator+(const CP &B) const { return CP(x + B.x, y + B.y); }
    CP operator-(const CP &B) const { return CP(x - B.x, y - B.y); }
    CP operator*(const CP &B) const { return CP(x * B.x - y * B.y, x * B.y + y * B.x); }
} f[MAXN], g[MAXN], sav[MAXN];
void FFT(CP *f, int limit, int type) {
    if (limit == 1) return;
    CP *fl = f, *fr = f + limit / 2;
    for (int i = 0; i < limit; i++) sav[i] = f[i];
    for (int i = 0; i < limit / 2; i++) fl[i] = sav[i << 1], fr[i] = sav[i << 1 | 1];
    FFT(fl, limit / 2, type);
    FFT(fr, limit / 2, type);
    CP Omega(cos(2.0 * PI / limit), type * sin(2.0 * PI / limit)), w(1, 0);
    for (int i = 0; i < limit / 2; i++, w = w * Omega)
        sav[i] = fl[i] + fr[i] * w, sav[i + limit / 2] = fl[i] - fr[i] * w;
    for (int i = 0; i < limit; i++) f[i] = sav[i];
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i <= n; i++) scanf("%lf", &f[i].x);
    for (int i = 0; i <= m; i++) scanf("%lf", &g[i].x);
    m += n, n = 1;
    while (n <= m) n <<= 1;
    FFT(f, n, 1), FFT(g, n, 1);
    for (int i = 0; i < n; i++) f[i] = f[i] * g[i];
    FFT(f, n, -1);
    for (int i = 0; i <= m; i++) printf("%d ", (int)(f[i].x / n + 0.5));
    return 0;
}\end{lstlisting}
\subsubsection{iteration.cpp}
\begin{lstlisting}[language={C++}]
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
#define db double
int read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f ^= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? x : -x;
}
void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
const db PI = acos(-1.0);
struct CP {
    db re, im;
    CP() { re = im = 0; }
    CP(db x, db y) { re = x, im = y; }
    CP operator+(const CP &b) const { return CP(re + b.re, im + b.im); }
    CP operator-(const CP &b) const { return CP(re - b.re, im - b.im); }
    CP operator*(const CP &b) const { return CP(re * b.re - im * b.im, re * b.im + im * b.re); }
};
#define N 3000005
int n, m, rev[N];
CP a[N], b[N];
inline void init(int n) {
    int b = log2(n);
    for (int i = 1; i < n; i++) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (b - 1));
}
inline void FFT(CP *a, int n, int op) {
    for (int i = 0; i < n; i++)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int len = 1; len <= (n >> 1); len <<= 1) {
        CP wn = CP(cos(PI / len), sin(PI / len) * op);
        for (int i = 0; i < n; i += (len << 1)) {
            CP w = CP(1.0, 0.0);
            for (int j = 0; j < len; j++, w = w * wn) {
                CP a0 = a[i + j], a1 = w * a[i + j + len];
                a[i + j] = a0 + a1, a[i + j + len] = a0 - a1;
            }
        }
    }
}
inline void IFFT(CP *a, int n) {
    FFT(a, n, -1);
    for (int i = 0; i < n; i++) a[i].re = a[i].re / n + 0.5;
}
int main() {
    n = read(), m = read();
    for (int i = 0; i <= n; i++) a[i].re = read();
    for (int i = 0; i <= m; i++) b[i].re = read();
    int len = 1;
    while (len <= n + m) len <<= 1;
    init(len);
    FFT(a, len, 1), FFT(b, len, 1);
    for (int i = 0; i < len; i++) a[i] = a[i] * b[i];
    IFFT(a, len);
    for (int i = 0; i <= n + m; i++) write(a[i].re), putchar(' ');
    return 0;
}\end{lstlisting}
\subsection{fwt.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#include <ext/pb_ds/priority_queue.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/trie_policy.hpp>
#define fi first
#define se second
#define mkp make_pair
#define pb push_back
#define eb emplace_back
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define gi int, vector<int>, greater<int>
#define IOS cin.tie(0)->sync_with_stdio(false), cout.tie(0)
#define fo(i, begin, end)                                                                                              \
    for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))
using namespace std;
using namespace __gnu_pbds;
using db = double;
using ll = long long;
using lint = __int128;
using pdd = pair<db, db>;
using pll = pair<ll, ll>;
using pdl = pair<db, ll>;
using pdi = pair<db, int>;
using pil = pair<int, ll>;
using pii = pair<int, int>;
using ull = unsigned ll;
using uint = unsigned int;
inline lint read() {
    lint x = 0;
    bool f = 0;
    char c = getchar();
    while (c < '0' || c > '9') f = (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? -x : x;
}
void write(lint x) {
    if (x < 0) { putchar('-'), x = -x; }
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
const db eps = 1e-10, PI = acos(-1.0);
const ll mod = 998244353, MOD = 1e9 + 7, inv2 = 499122177;
const int N = (1 << 17) + 5;
const ll Cor[2][2] = {{1, 0}, {1, 1}};
const ll ICor[2][2] = {{1, 0}, {mod - 1, 1}};
const ll Cand[2][2] = {{1, 1}, {0, 1}};
const ll ICand[2][2] = {{1, mod - 1}, {0, 1}};
const ll Cxor[2][2] = {{1, 1}, {1, mod - 1}};
const ll ICxor[2][2] = {{inv2, inv2}, {inv2, mod - inv2}};
inline void FWT(ll *f, const ll c[2][2], int n) {
    for (int len = 1; len < n; len <<= 1)
        for (int p = 0; p < n; p += len + len)
            for (int i = p; i < p + len; ++i) {
                int tmp = f[i];
                f[i] = (c[0][0] * f[i] + c[0][1] * f[i + len]) % mod;
                f[i + len] = (c[1][0] * tmp + c[1][1] * f[i + len]) % mod;
            }
}
inline void mul(ll *f, ll *g, const ll c[2][2], const ll ic[2][2], int n) {
    FWT(f, c, n), FWT(g, c, n);
    fo(i, 0, n) f[i] = (f[i] * g[i]) % mod;
    FWT(f, ic, n);
}
int n;
ll a[N], b[N], f[N], g[N];
inline void work(const ll c[2][2], const ll ic[2][2]) {
    fo(i, 0, n) f[i] = a[i];
    fo(i, 0, n) g[i] = b[i];
    mul(f, g, c, ic, n);
    fo(i, 0, n) cout << f[i] << ' ';
    cout << '\n';
}
int main() {
    IOS;
    cin >> n, n = (1 << n);
    fo(i, 0, n) cin >> a[i];
    fo(i, 0, n) cin >> b[i];
    work(Cor, ICor), work(Cand, ICand), work(Cxor, ICxor);
    return 0;
}\end{lstlisting}
\subsection{ntt.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <vector>
using namespace std;
int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0') {
        x = 10 * x + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void print(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x >= 10) print(x / 10);
    putchar(x % 10 + '0');
}
constexpr int N = 300100, P = 998244353;
int qpow(int x, int y) {
    int res(1);
    while (y) {
        if (y & 1) res = 1ll * res * x % P;
        x = 1ll * x * x % P;
        y >>= 1;
    }
    return res;
}
int r[N];
void ntt(int *x, int lim, int opt) {
    int i, j, k, m, gn, g, tmp;
    for (i = 0; i < lim; ++i)
        if (r[i] < i) swap(x[i], x[r[i]]);
    for (m = 2; m <= lim; m <<= 1) {
        k = m >> 1;
        gn = qpow(3, (P - 1) / m);
        for (i = 0; i < lim; i += m) {
            g = 1;
            for (j = 0; j < k; ++j, g = 1ll * g * gn % P) {
                tmp = 1ll * x[i + j + k] * g % P;
                x[i + j + k] = (x[i + j] - tmp + P) % P;
                x[i + j] = (x[i + j] + tmp) % P;
            }
        }
    }
    if (opt == -1) {
        reverse(x + 1, x + lim);
        int inv = qpow(lim, P - 2);
        for (i = 0; i < lim; ++i) x[i] = 1ll * x[i] * inv % P;
    }
}
int A[N], B[N], C[N];
char a[N], b[N];
int main() {
    int i, lim(1), n;
    scanf("%s", a);
    n = strlen(a);
    for (i = 0; i < n; ++i) A[i] = a[n - i - 1] - '0';
    while (lim < (n << 1)) lim <<= 1;
    scanf("%s", b);
    n = strlen(b);
    for (i = 0; i < n; ++i) B[i] = b[n - i - 1] - '0';
    while (lim < (n << 1)) lim <<= 1;
    for (i = 0; i < lim; ++i) r[i] = (i & 1) * (lim >> 1) + (r[i >> 1] >> 1);
    ntt(A, lim, 1);
    ntt(B, lim, 1);
    for (i = 0; i < lim; ++i) C[i] = 1ll * A[i] * B[i] % P;
    ntt(C, lim, -1);
    int len(0);
    for (i = 0; i < lim; ++i) {
        if (C[i] >= 10) len = i + 1, C[i + 1] += C[i] / 10, C[i] %= 10;
        if (C[i]) len = max(len, i);
    }
    while (C[len] >= 10) C[len + 1] += C[len] / 10, C[len] %= 10, len++;
    for (i = len; ~i; --i) putchar(C[i] + '0');
    puts("");
    return 0;
}\end{lstlisting}
\section{bignum.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <cstring>
constexpr int LEN = 1004;
int a[LEN], b[LEN], c[LEN], d[LEN];
void clear(int a[]) {
    for (int i = 0; i < LEN; ++i) a[i] = 0;
}
void read(int a[]) {
    static char s[LEN + 1];
    scanf("%s", s);
    clear(a);
    int len = strlen(s);
    for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
}
void print(int a[]) {
    int i;
    for (i = LEN - 1; i >= 1; --i)
        if (a[i] != 0) break;
    for (; i >= 0; --i) putchar(a[i] + '0');
    putchar('\n');
}
void add(int a[], int b[], int c[]) {
    clear(c);
    for (int i = 0; i < LEN - 1; ++i) {
        c[i] += a[i] + b[i];
        if (c[i] >= 10) {
            c[i + 1] += 1;
            c[i] -= 10;
        }
    }
}
void sub(int a[], int b[], int c[]) {
    clear(c);
    for (int i = 0; i < LEN - 1; ++i) {
        c[i] += a[i] - b[i];
        if (c[i] < 0) {
            c[i + 1] -= 1;
            c[i] += 10;
        }
    }
}
void mul(int a[], int b[], int c[]) {
    clear(c);
    for (int i = 0; i < LEN - 1; ++i) {
        for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];
        if (c[i] >= 10) {
            c[i + 1] += c[i] / 10;
            c[i] %= 10;
        }
    }
}
bool greater_eq(int a[], int b[], int last_dg, int len) {
    if (a[last_dg + len] != 0) return true;
    for (int i = len - 1; i >= 0; --i) {
        if (a[last_dg + i] > b[i]) return true;
        if (a[last_dg + i] < b[i]) return false;
    }
    return true;
}
void div(int a[], int b[], int c[], int d[]) {
    clear(c), clear(d);
    int la, lb;
    for (la = LEN - 1; la > 0; --la)
        if (a[la - 1] != 0) break;
    for (lb = LEN - 1; lb > 0; --lb)
        if (b[lb - 1] != 0) break;
    if (lb == 0) {
        puts("> <");
        return;
    }
    for (int i = 0; i < la; ++i) d[i] = a[i];
    for (int i = la - lb; i >= 0; --i) {
        while (greater_eq(d, b, i, lb)) {
            for (int j = 0; j < lb; ++j) {
                d[i + j] -= b[j];
                if (d[i + j] < 0) {
                    d[i + j + 1] -= 1;
                    d[i + j] += 10;
                }
            }
            c[i] += 1;
        }
    }
}
int main() {
    read(a);
    char op[4];
    scanf("%s", op);
    read(b);
    switch (op[0]) {
    case '+': add(a, b, c), print(c); break;
    case '-': sub(a, b, c), print(c); break;
    case '*': mul(a, b, c), print(c); break;
    case '/': div(a, b, c, d), print(c), print(d); break;
    default: puts("> <");
    }
    return 0;
}\end{lstlisting}
\section{binary-exponentiation.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
using ll = long long;
inline ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    if (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod, b >>= 1;
    }
    return res % mod;
}
int main() { return 0; }\end{lstlisting}
\section{gauss.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
double map[111][111];
double ans[111];
double eps = 1e-7;
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n + 1; j++) scanf("%lf", &map[i][j]);
    for (int i = 1; i <= n; i++) {
        int r = i;
        for (int j = i + 1; j <= n; j++)
            if (fabs(map[r][i]) < fabs(map[j][i])) r = j; // find_the_biggest_number_of_the_first_column（at present)
        if (fabs(map[r][i]) < eps) {
            printf("No Solution");
            return 0;
        }
        if (i != r)
            swap(map[i], map[r]); // 对换一行或一列,属于找最大当前系数的其中一步。（这样就可以只处理当前行的系数啦！）
        double div = map[i][i];
        for (int j = i; j <= n + 1; j++) map[i][j] /= div;
        for (int j = i + 1; j <= n; j++) {
            div = map[j][i];
            for (int k = i; k <= n + 1; k++) map[j][k] -= map[i][k] * div;
        }
    }
    ans[n] = map[n][n + 1];
    for (int i = n - 1; i >= 1; i--) {
        ans[i] = map[i][n + 1];
        for (int j = i + 1; j <= n; j++) ans[i] -= (map[i][j] * ans[j]);
    } // 回带操作
    for (int i = 1; i <= n; i++) printf("%.2lf\n", ans[i]);
    return 0;
}\end{lstlisting}
\section{quick-pow.cpp}
\begin{lstlisting}[language={C++}]
/*
可以在 O(log n) 的时间内求出a^b%p的值。

不需要任何头文件。

最初编辑人：01bit
最后修改人：SnowFlavour
*/

using ll = long long;
ll p;
ll qpow(ll x, ll y) {
    ll z = 1;
    while (y) {
        if (y & 1) z = z * x % p;
        x = x * x % p;
        y >>= 1;
    }
    return z;
}\end{lstlisting}
\chapter{数据结构Data Structure}
\section{bst}
\subsection{fhq-treap.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int N = 1e5 + 10;
int n, rt, L, R, p, cnt;
struct node {
    int ls, rs, val, pri, siz;
    node() {}
    node(int _l, int _r, int _v, int _p, int _s) { ls = _l, rs = _r, val = _v, pri = _p, siz = _s; }
} t[N];
void pushup(int u) { t[u].siz = t[t[u].ls].siz + t[t[u].rs].siz + 1; }
void newnode(int x) { t[++cnt] = node(0, 0, x, rng(), 1); }
void split(int u, int x, int &L, int &R) {
    if (!u) return L = R = 0, void();
    if (t[u].val <= x) L = u, split(t[u].rs, x, t[u].rs, R);
    else R = u, split(t[u].ls, x, L, t[u].ls);
    pushup(u);
}
int merge(int L, int R) {
    if (!L || !R) return L | R;
    if (t[L].pri <= t[R].pri) return t[L].rs = merge(t[L].rs, R), pushup(L), L;
    else return t[R].ls = merge(L, t[R].ls), pushup(R), R;
}
inline void Insert(int x) { newnode(x), split(rt, x, L, R), rt = merge(merge(L, cnt), R); }
inline void Delete(int x) {
    split(rt, x - 1, L, R), split(R, x, p, R);
    p = merge(t[p].ls, t[p].rs), rt = merge(merge(L, p), R);
}
inline int get_rank(int x) {
    split(rt, x - 1, L, R);
    int y = t[L].siz + 1;
    rt = merge(L, R);
    return y;
}
inline int get_val(int u, int k) {
    int now = u;
    while (now) {
        int x = t[t[now].ls].siz + 1;
        if (x == k) return t[now].val;
        if (x < k) now = t[now].rs, k -= x;
        else now = t[now].ls;
    }
}
inline int get_pre(int x) {
    split(rt, x - 1, L, R);
    int y = get_val(L, t[L].siz);
    rt = merge(L, R);
    return y;
}
inline int get_nxt(int x) {
    split(rt, x, L, R);
    int y = get_val(R, 1);
    rt = merge(L, R);
    return y;
}
signed main() { return 0; }\end{lstlisting}
\subsection{splay.cpp}
\begin{lstlisting}[language={C++}]
const int N = 1e5 + 5;
int rt, siz[N], ch[N][2], val[N], tot, fa[N], cnt[N];
void pushup(int p) { siz[p] = siz[ch[p][0]] + siz[ch[p][1]] + cnt[p]; }
bool get(int p) { return p == ch[fa[p]][1]; }
void clear(int p) { siz[p] = ch[p][0] = ch[p][1] = val[p] = fa[p] = cnt[p] = 0; }
void rotate(int p) {
    int f = fa[p], g = fa[f], chk = get(p);
    ch[f][chk] = ch[p][chk ^ 1];
    if (ch[p][chk ^ 1]) fa[ch[p][chk ^ 1]] = f;
    ch[p][chk ^ 1] = f, fa[f] = p, fa[p] = g;
    if (g) ch[g][f == ch[g][1]] = p;
    pushup(f), pushup(p);
}
void splay(int p) {
    for (int f = fa[p]; f = fa[p], f; rotate(p))
        if (fa[f]) rotate(get(p) == get(f) ? f : p);
    rt = p;
}
void nw(int k, int fath, int op) { val[++tot] = k, siz[tot] = cnt[tot] = 1, fa[tot] = fath, ch[fath][op] = tot; }
void ins(int k) {
    if (!rt) {
        val[++tot] = k, cnt[tot]++, rt = tot;
        return pushup(rt);
    }
    int cur = rt, f = 0;
    while (1) {
        if (val[cur] == k) {
            cnt[cur]++;
            pushup(cur), pushup(f), splay(cur);
            break;
        }
        f = cur, cur = ch[cur][val[cur] < k];
        if (!cur) {
            val[++tot] = k;
            cnt[tot]++, fa[tot] = f, ch[f][val[f] < k] = tot;
            pushup(tot), pushup(f), splay(tot);
            break;
        }
    }
}
int rk(int k) {
    int p = rt, res = 0;
    while (true) {
        if (k < val[p]) p = ch[p][0];
        else {
            res += siz[ch[p][0]];
            if (!p) return res + 1;
            if (val[p] == k) return splay(p), res + 1;
            res += cnt[p], p = ch[p][1];
        }
    }
}
int prev() {
    int p = ch[rt][0];
    if (!p) return p;
    while (ch[p][1]) p = ch[p][1];
    return splay(p), p;
}
int next() {
    int p = ch[rt][1];
    if (!p) return p;
    while (ch[p][0]) p = ch[p][0];
    return splay(p), p;
}
void del(int k) {
    rk(k);
    if (cnt[rt] > 1) return --cnt[rt], pushup(rt), void();
    if (!ch[rt][0] && !ch[rt][1]) return clear(rt), rt = 0, void();
    if (!ch[rt][0]) {
        int cur = rt;
        rt = ch[rt][1], fa[rt] = 0;
        clear(cur);
        return;
    }
    if (!ch[rt][1]) {
        int cur = rt;
        rt = ch[rt][0], fa[rt] = 0;
        clear(cur);
        return;
    }
    int cur = rt, x = prev();
    fa[ch[cur][1]] = x, ch[x][1] = ch[cur][1];
    clear(cur), pushup(rt);
}
int kth(int k) {
    int p = rt;
    while (1) {
        if (ch[p][0] && k <= siz[ch[p][0]]) p = ch[p][0];
        else {
            k -= cnt[p] + siz[ch[p][0]];
            if (k <= 0) return splay(p), val[p];
            p = ch[p][1];
        }
    }
}\end{lstlisting}
\section{dsu}
\section{dynamic-tree}
\subsection{lct.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 5;
int n, m, fa[N], ch[N][2], val[N], tag[N], sum[N];
inline int get(int p) { return ch[fa[p]][1] == p; }
inline bool is_root(int p) { return ch[fa[p]][0] != p && ch[fa[p]][1] != p; }
inline void pushup(int p) { sum[p] = sum[ch[p][0]] ^ val[p] ^ sum[ch[p][1]]; }
inline void reverse(int p) { swap(ch[p][0], ch[p][1]), tag[p] ^= 1; }
inline void pushdown(int p) {
    if (!tag[p]) return;
    reverse(ch[p][0]), reverse(ch[p][1]), tag[p] = 0;
}
inline void push(int p) {
    if (!is_root(p)) push(fa[p]);
    pushdown(p);
}
inline void rotate(int p) {
    int f = fa[p], g = fa[f], k = get(p);
    if (!is_root(f)) ch[g][get(f)] = p;
    ch[f][k] = ch[p][k ^ 1], fa[ch[p][k ^ 1]] = f;
    ch[p][k ^ 1] = f, fa[f] = p, fa[p] = g;
    pushup(f), pushup(p);
}
void splay(int p) {
    push(p);
    for (int f; f = fa[p], !is_root(p); rotate(p))
        if (!is_root(f)) rotate(get(p) == get(f) ? f : p);
}
inline void access(int p) {
    for (int child = 0; p; child = p, p = fa[p]) splay(p), ch[p][1] = child, pushup(p);
}
inline void makeroot(int p) { access(p), splay(p), reverse(p); }
inline void split(int u, int v) { makeroot(u), access(v), splay(v); }
inline int findroot(int p) {
    access(p), splay(p), pushdown(p);
    while (ch[p][0]) p = ch[p][0], pushdown(p);
    return splay(p), p;
}
inline void link(int u, int v) { makeroot(u), fa[u] = v; }
inline void cut(int u, int v) {
    makeroot(u);
    if (findroot(v) == u && fa[v] == u && !ch[v][0]) fa[v] = ch[u][1] = 0, pushup(u);
}
int main() {
    cin.tie(0)->sync_with_stdio(false);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> val[i];
    for (int op, x, y; m--;) {
        cin >> op >> x >> y;
        switch (op) {
        case 0: split(x, y), cout << sum[y] << '\n'; break;
        case 1:
            if (findroot(x) != findroot(y)) link(x, y);
            break;
        case 2: cut(x, y); break;
        case 3: splay(x), val[x] = y; break;
        }
    }
    return 0;
}
\end{lstlisting}
\section{fenwick}
\subsection{fenwick-1.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
using namespace std;
const int N = 5e5 + 10;
int n, m, a[N];
struct BIT {
    int tr[N];
    inline int lowbit(int x) { return x & -x; }
    inline void upd(int x, int c) {
        while (x <= n) tr[x] += c, x += lowbit(x);
    }
    inline int que(int x) {
        int res = 0;
        while (x) res += tr[x], x -= lowbit(x);
        return res;
    }
} tree;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i], tree.upd(i, a[i]);
    while (m--) {
        int op, x, y;
        cin >> op >> x >> y;
        if (op == 1) tree.upd(x, y);
        else cout << tree.que(y) - tree.que(x - 1) << "\n";
    }
    return 0;
}\end{lstlisting}
\subsection{fenwick-2.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
using namespace std;
const int N = 500005;
int n, m, a[N], s[N], t[N];
inline int lowbit(int s) { return s & -s; }
inline void add(int x, int k) {
    for (; x <= n; x += lowbit(x)) t[x] += k;
}
inline int query(int x) {
    int res = 0;
    for (; x; x -= lowbit(x)) res += t[x];
    return res;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    while (m--) {
        int op, x, y, k;
        cin >> op >> x;
        if (op == 1) {
            cin >> y >> k;
            add(x, k);
            add(y + 1, -k);
        } else cout << a[x] + query(x) << "\n";
    }
    return 0;
}\end{lstlisting}
\section{segment-tree}
\subsection{persistant}
\subsubsection{persistant-seg1.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
using namespace std;
const int N = 1e6 + 5;
int n, m, a[N], tot;
int root[N], cnt;
struct node {
    int ls, rs;
    int val;
} tree[N * 30];
int build(int pl, int pr) {
    int rt = tot++;
    if (pl == pr) {
        tree[rt].val = a[pl];
        return rt;
    }
    int mid = (pl + pr) >> 1;
    tree[rt].ls = build(pl, mid);
    tree[rt].rs = build(mid + 1, pr);
    return rt;
}
int update(int pre, int pl, int pr, int loc, int val) {
    int rt = tot++;
    if (pl == pr) {
        tree[rt].val = val;
        return rt;
    }
    int mid = (pl + pr) >> 1;
    tree[rt].ls = tree[pre].ls;
    tree[rt].rs = tree[pre].rs;
    if (loc <= mid) tree[rt].ls = update(tree[pre].ls, pl, mid, loc, val);
    else tree[rt].rs = update(tree[rt].rs, mid + 1, pr, loc, val);
    return rt;
}
int query(int p, int pl, int pr, int loc) {
    if (pl == pr) return tree[p].val;
    int mid = (pl + pr) >> 1;
    if (loc <= mid) return query(tree[p].ls, pl, mid, loc);
    else return query(tree[p].rs, mid + 1, pr, loc);
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    root[cnt++] = build(1, n);
    while (m--) {
        int v, op, loc, val;
        scanf("%d%d%d", &v, &op, &loc);
        if (op == 1) {
            scanf("%d", &val);
            root[cnt++] = update(root[v], 1, n, loc, val);
        } else {
            root[cnt++] = root[v];
            int res = query(root[v], 1, n, loc);
            printf("%d\n", res);
        }
    }
    return 0;
}\end{lstlisting}
\subsubsection{persistant-seg2.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <cstdio>
#include <iostream>
#define endl '\n'
using std::cin;
using std::cout;
using std::lower_bound;
using std::sort;
using std::unique;
const int N = 2e5 + 5;
int n, m, a[N], b[N], size, tot;
int root[N], vcnt;
struct node {
    int l, r;
    int sum;
} tree[N * 30];
int build(int pl, int pr) {
    int rt = ++tot;
    tree[rt].sum = 0;
    int mid = (pl + pr) >> 1;
    if (pl < pr) {
        tree[rt].l = build(pl, mid);
        tree[rt].r = build(mid + 1, pr);
    }
    return rt;
}
int update(int pre, int pl, int pr, int x) {
    int rt = ++tot;
    tree[rt].l = tree[pre].l;
    tree[rt].r = tree[pre].r;
    tree[rt].sum = tree[pre].sum + 1;
    int mid = (pl + pr) >> 1;
    if (pl < pr) {
        if (x <= mid) tree[rt].l = update(tree[pre].l, pl, mid, x);
        else tree[rt].r = update(tree[pre].r, mid + 1, pr, x);
    }
    return rt;
}
int query(int u, int v, int pl, int pr, int k) {
    if (pl == pr) return pl;
    int x = tree[tree[v].l].sum - tree[tree[u].l].sum;
    int mid = (pl + pr) >> 1;
    if (x >= k) return query(tree[u].l, tree[v].l, pl, mid, k);
    else return query(tree[u].r, tree[v].r, mid + 1, pr, k - x);
}
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b + 1, b + 1 + n);
    size = unique(b + 1, b + 1 + n) - (b + 1);
    root[0] = build(1, size);
    for (int i = 1; i <= n; i++) {
        int x = lower_bound(b + 1, b + 1 + size, a[i]) - b;
        root[i] = update(root[i - 1], 1, size, x);
    }
    while (m--) {
        int l, r, k;
        cin >> l >> r >> k;
        int res = query(root[l - 1], root[r], 1, size, k);
        cout << b[res] << endl;
    }
    return 0;
}\end{lstlisting}
\subsection{lc-segment.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pdi = pair<double, int>;
constexpr int N = 4e4 + 5, M1 = 39989, M2 = 1e9;
constexpr double eps = 1e-9;
int comp(double a, double b) {
    if (a - b > eps) return 1;
    if (b - a > eps) return -1;
    return 0;
}
struct LiChaoT {
    int cnt, t[N << 2];
    struct line {
        double k, b;
        double operator()(int x) { return k * x + b; }
    } seg[N << 2];
    void add(int x1, int y1, int x2, int y2) {
        double k, b;
        if (x2 == x1) k = 0, b = max(y1, y2);
        else k = 1.0 * (y2 - y1) / (x2 - x1), b = y1 - x1 * k;
        seg[++cnt] = {k, b};
    }
    void update(int rt, int L, int R, int x) {
        int &v = t[rt];
        int mid = (L + R) / 2;
        if (comp(seg[v](mid), seg[x](mid)) < 0) swap(v, x);
        if (comp(seg[v](L), seg[x](L)) < 0) update(rt << 1, L, mid, x);
        if (comp(seg[v](R), seg[x](R)) < 0) update(rt << 1 | 1, mid + 1, R, x);
    }
    void insert(int rt, int L, int R, int l, int r, int x) {
        if (l <= L && R <= r) return update(rt, L, R, x);
        int mid = (L + R) / 2;
        if (l <= mid) insert(rt << 1, L, mid, l, r, x);
        if (r > mid) insert(rt << 1 | 1, mid + 1, R, l, r, x);
    }
    pdi mx(pdi a, pdi b) {
        int c = comp(a.first, b.first);
        if (c > 0) return a;
        if (c < 0) return b;
        return a.second < b.second ? a : b;
    }
    pdi query(int rt, int L, int R, int x) {
        if (x < L || x > R) return {0, 0};
        pdi ret = {seg[t[rt]](x), t[rt]};
        if (L == R) return ret;
        int mid = (L + R) / 2;
        return mx(ret, mx(query(rt << 1, L, mid, x), query(rt << 1 | 1, mid + 1, R, x)));
    }
} t;
int main() {
    cin.tie(nullptr), cout.tie(nullptr);
    ios::sync_with_stdio(0);
    int n, last = 0;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int op, k, x, y, xx, yy;
        cin >> op;
        if (op == 0) {
            cin >> k;
            k = (k + last - 1) % M1 + 1;
            cout << (last = t.query(1, 0, 40000, k).second) << '\n';
        } else {
            cin >> x >> y >> xx >> yy;
            x = (x + last - 1) % M1 + 1, xx = (xx + last - 1) % M1 + 1;
            y = (y + last - 1) % M2 + 1, yy = (yy + last - 1) % M2 + 1;
            t.add(x, y, xx, yy), t.insert(1, 0, 40000, min(x, xx), max(x, xx), t.cnt);
        }
    }
    return 0;
}\end{lstlisting}
\subsection{sgt-1.cpp}
\begin{lstlisting}[language={C++}]
#include <iostream>
using namespace std;
using ll = long long;
namespace segment_tree {
#define ls (p << 1)
#define rs (p << 1 | 1)
#define mid (pl + pr >> 1)
const int N = 1e6 + 5;
int sum[N], tag[N];
inline void up(int p) { sum[p] = sum[ls] + sum[rs]; }
inline void spread(int p, int pl, int pr) {
    if (!tag[p]) return;
    tag[ls] += tag[p], tag[rs] += tag[p];
    sum[ls] += tag[p] * (mid - pl + 1), sum[rs] += tag[p] * (pr - mid);
    tag[p] = 0;
}
void build(int p, int pl, int pr, int *a) {
    if (pl == pr) return sum[p] = a[pl], void();
    build(ls, pl, mid, a), build(rs, mid + 1, pr, a), up(p);
}
void update(int p, int pl, int pr, int L, int R, int v) {
    if (L <= pl && pr <= R) return sum[p] += v, void();
    spread(p, pl, pr);
    if (L <= mid) update(ls, pl, mid, L, R, v);
    if (R > mid) update(rs, mid + 1, pr, L, R, v);
    up(p);
}
int query(int p, int pl, int pr, int L, int R) {
    if (L <= pl && pr <= R) return sum[p];
    spread(p, pl, pr);
    int res(0);
    if (L <= mid) res += query(ls, pl, mid, L, R);
    if (R > mid) res += query(rs, mid + 1, pr, L, R);
    return res;
}
}; // namespace segment_tree
int main() { return 0; }\end{lstlisting}
\subsection{sgt-2.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <iostream>
#define int long long
using namespace std;
int n, m, mod, a[101000];
struct node {
    int l, r, sum;
    int add, mul;
} t[401000];
void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    t[p].mul = 1, t[p].add = 0;
    if (l == r) {
        t[p].sum = a[l];
        return;
    }
    int mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}
void push_down(int p) {
    if (t[p].mul != 1) {
        t[p * 2].mul *= t[p].mul, t[p * 2].mul %= mod;
        t[p * 2 + 1].mul *= t[p].mul, t[p * 2 + 1].mul %= mod;
        t[p * 2].sum *= t[p].mul, t[p * 2].sum %= mod;
        t[p * 2 + 1].sum *= t[p].mul, t[p * 2 + 1].sum %= mod;
        t[p * 2].add *= t[p].mul, t[p * 2].add %= mod;
        t[p * 2 + 1].add *= t[p].mul, t[p * 2 + 1].add %= mod;
        t[p].mul = 1;
    }
    if (t[p].add != 0) {
        t[p * 2].add += t[p].add, t[p * 2].add %= mod;
        t[p * 2 + 1].add += t[p].add, t[p * 2 + 1].add %= mod;
        t[p * 2].sum += t[p].add * (t[p * 2].r - t[p * 2].l + 1), t[p * 2].sum %= mod;
        t[p * 2 + 1].sum += t[p].add * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1), t[p * 2 + 1].sum %= mod;
        t[p].add = 0;
    }
}
void mulnum(int p, int dat, int l, int r) {
    if (l <= t[p].l && r >= t[p].r) {
        t[p].mul *= dat, t[p].mul %= mod;
        t[p].sum *= dat, t[p].sum %= mod;
        t[p].add *= dat, t[p].add %= mod;
        return;
    }
    push_down(p);
    int mid = (t[p].l + t[p].r) / 2;
    if (l <= mid) mulnum(p * 2, dat, l, r);
    if (r > mid) mulnum(p * 2 + 1, dat, l, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}
void addnum(int p, int dat, int l, int r) {
    if (l <= t[p].l && r >= t[p].r) {
        t[p].add += dat, t[p].add %= mod;
        t[p].sum += dat * (t[p].r - t[p].l + 1), t[p].sum %= mod;
        return;
    }
    push_down(p);
    int mid = (t[p].l + t[p].r) / 2;
    if (l <= mid) addnum(p * 2, dat, l, r);
    if (r > mid) addnum(p * 2 + 1, dat, l, r);
    t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
}
int query(int p, int l, int r) {
    if (l <= t[p].l && r >= t[p].r) return t[p].sum % mod;
    push_down(p);
    int mid = (t[p].l + t[p].r) / 2, val = 0;
    if (l <= mid) val += query(p * 2, l, r);
    if (r > mid) val += query(p * 2 + 1, l, r);
    return val % mod;
}
signed main() {
    cin >> n >> m >> mod;
    for (int i = 1; i <= n; i++) cin >> a[i];
    build(1, 1, n);
    while (m--) {
        int op, x, y, k;
        cin >> op >> x >> y;
        if (op == 1) {
            cin >> k;
            mulnum(1, k, x, y);
        } else if (op == 2) {
            cin >> k;
            addnum(1, k, x, y);
        } else cout << query(1, x, y) << endl;
    }
    return 0;
}\end{lstlisting}
\subsection{sgt-merge.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 100005, M = 100000;
int n, m, head[N], tot, ans[N];
struct edge {
    int v, nxt;
} e[N << 1];
inline void add(int u, int v) {
    e[++tot].v = v;
    e[tot].nxt = head[u];
    head[u] = tot;
}
int fa[N], dep[N], siz[N], hson[N], dfn[N], top[N], Time;
void dfs1(int u, int fath) {
    fa[u] = fath, dep[u] = dep[fath] + 1, siz[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fath) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (!hson[u] || siz[v] > siz[hson[u]]) hson[u] = v;
    }
}
void dfs2(int u, int tp) {
    top[u] = tp, dfn[u] = ++Time;
    if (hson[u]) dfs2(hson[u], tp);
    for (int i = head[u]; i; i = e[i].nxt)
        if (e[i].v != fa[u] && e[i].v != hson[u]) dfs2(e[i].v, e[i].v);
}
inline int LCA(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    return dep[x] <= dep[y] ? x : y;
}
int cnt = 0, rt[N];
struct node {
    int mx, id;
    int ls, rs;
} t[N * 100];
void pushup(int p) {
    if (t[t[p].ls].mx >= t[t[p].rs].mx) t[p].mx = t[t[p].ls].mx, t[p].id = t[t[p].ls].id;
    else t[p].mx = t[t[p].rs].mx, t[p].id = t[t[p].rs].id;
}
void update(int &p, int pl, int pr, int k, int val) {
    if (!p) p = ++cnt;
    if (pl == pr) {
        t[p].mx += val, t[p].id = k;
        return;
    }
    int mid = (pl + pr) >> 1;
    if (k <= mid) update(t[p].ls, pl, mid, k, val);
    else update(t[p].rs, mid + 1, pr, k, val);
    pushup(p);
}
int merge(int &L, int &R, int pl, int pr) {
    if (!L) return R;
    if (!R) return L;
    if (pl == pr) {
        t[L].mx += t[R].mx;
        return L;
    }
    int mid = (pl + pr) >> 1;
    t[L].ls = merge(t[L].ls, t[R].ls, pl, mid);
    t[L].rs = merge(t[L].rs, t[R].rs, mid + 1, pr);
    pushup(L);
    return L;
}
void dfs(int u) {
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa[u]) continue;
        dfs(v);
        rt[u] = merge(rt[u], rt[v], 1, M);
    }
    ans[u] = t[rt[u]].id;
    if (!t[rt[u]].mx) ans[u] = 0;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs1(1, 0);
    dfs2(1, 1);
    while (m--) {
        int l, r, z;
        cin >> l >> r >> z;
        update(rt[l], 1, M, z, 1);
        update(rt[r], 1, M, z, 1);
        int lca = LCA(l, r);
        update(rt[lca], 1, M, z, -1);
        update(rt[fa[lca]], 1, M, z, -1);
    }
    dfs(1);
    for (int i = 1; i <= n; i++) cout << ans[i] << "\n";
    return 0;
}\end{lstlisting}
\subsection{sgt-split.cpp}
\begin{lstlisting}[language={C++}]
#include <cstdio>
#include <iostream>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n, m, root[N << 2], rcnt = 1, rub[N << 5], cnt, nodecnt;
struct treenode {
    int ls, rs, sum;
} tr[N << 5];
inline int newnode() { return cnt ? rub[cnt--] : ++nodecnt; }
inline void del(int &p) { tr[p].ls = tr[p].rs = tr[p].sum = 0, rub[++cnt] = p, p = 0; }
inline void push_up(int p) { tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum; }
inline void build(int &p, int pl, int pr) {
    if (!p) p = newnode();
    if (pl == pr) return cin >> tr[p].sum, void();
    int mid = (pl + pr) >> 1;
    build(tr[p].ls, pl, mid), build(tr[p].rs, mid + 1, pr);
    push_up(p);
}
inline void update(int &p, int pl, int pr, int pos, int k) {
    if (!p) p = newnode();
    if (pl == pr) return tr[p].sum += k, void();
    int mid = (pl + pr) >> 1;
    if (pos <= mid) update(tr[p].ls, pl, mid, pos, k);
    else update(tr[p].rs, mid + 1, pr, pos, k);
    push_up(p);
}
inline int merge(int p, int q, int pl, int pr) {
    if (!p || !q) return p + q;
    if (pl == pr) return tr[p].sum += tr[q].sum, del(q), p;
    int mid = (pl + pr) >> 1;
    tr[p].ls = merge(tr[p].ls, tr[q].ls, pl, mid);
    tr[p].rs = merge(tr[p].rs, tr[q].rs, mid + 1, pr);
    return push_up(p), del(q), p;
}
inline void split(int &p, int &q, int pl, int pr, int L, int R) {
    if (R < pl || L > pr) return;
    if (!p) return;
    if (L <= pl && pr <= R) return q = p, p = 0, void();
    int mid = (pl + pr) >> 1;
    if (!q) q = newnode();
    if (L <= mid) split(tr[p].ls, tr[q].ls, pl, mid, L, R);
    if (R > mid) split(tr[p].rs, tr[q].rs, mid + 1, pr, L, R);
    push_up(p), push_up(q);
}
inline int query(int p, int pl, int pr, int L, int R) {
    if (!p) return 0;
    if (L <= pl && pr <= R) return tr[p].sum;
    int mid = (pl + pr) >> 1, res = 0;
    if (L <= mid) res += query(tr[p].ls, pl, mid, L, R);
    if (R > mid) res += query(tr[p].rs, mid + 1, pr, L, R);
    return res;
}
inline int kth(int p, int pl, int pr, int k) {
    if (pl == pr) return pl;
    int mid = (pl + pr) >> 1, left = tr[tr[p].ls].sum;
    if (k <= left) return kth(tr[p].ls, pl, mid, k);
    else return kth(tr[p].rs, mid + 1, pr, k - left);
}
signed main() {
    cin.tie(0)->sync_with_stdio(false);
    cout.tie(0);
    cin >> n >> m;
    build(root[1], 1, n);
    for (int i = 1, op, p, x, y; i <= m; i++) {
        cin >> op >> p >> x;
        if (op == 0 || op == 2 || op == 3) cin >> y;
        if (op == 0) split(root[p], root[++rcnt], 1, n, x, y);
        else if (op == 1) root[p] = merge(root[p], root[x], 1, n);
        else if (op == 2) update(root[p], 1, n, y, x);
        else if (op == 3) cout << query(root[p], 1, n, x, y) << "\n";
        else if (op == 4) {
            if (tr[root[p]].sum < x) cout << "-1\n";
            else cout << kth(root[p], 1, n, x) << "\n";
        }
    }
    return 0;
}\end{lstlisting}
\section{st-table}
\section{dsu.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
struct dsu {
    vector<size_t> pa, size;
    explicit dsu(size_t size_) : pa(size_), size(size_, 1) { iota(pa.begin(), pa.end(), 0); }
    inline size_t find(int x) { return pa[x] == x ? x : pa[x] = find(pa[x]); }
    void unite(size_t x, size_t y) {
        x = find(x), y = find(y);
        if (x == y) return;
        if (size[x] < size[y]) swap(x, y);
        pa[y] = x;
        size[x] += size[y];
    }
    void erase(size_t x) { --size[find(x)], pa[x] = x; }
    void dsu::move(size_t x, size_t y) {
        auto fx = find(x), fy = find(y);
        if (fx == fy) return;
        pa[x] = fy;
        --size[fx], ++size[fy];
    }
};
\end{lstlisting}
\section{st-table.cpp}
\begin{lstlisting}[language={C++}]
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
int n, m, a[1010000], st[1010000][200];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) scanf("%d", a + i), st[i][i] = a[i];
    for (int j = 1; 1 + (1 << j) <= n; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++) st[i][j] = max(st[i][j - 1], st[i + (1 << j - 1)][j - 1]);
    while (m--) {
        int l, r, ans;
        scanf("%d%d", &l, &r);
        int t = log2(r - l + 1);
        ans = max(st[l][t], st[r - (1 << t) + 1][t]);
        printf("%d\n", ans);
    }
    return 0;
}\end{lstlisting}
\chapter{杂项Misc}
\section{offline}
\subsection{mo}
\subsubsection{mo-algo.cpp}
\begin{lstlisting}[language={C++}]
void move(int pos, int sign) { ... }
int unit;
struct node {
    int l, r, id;
    bool operator<(const node &x) const {
        return l / unit == x.l / unit ? (r == x.r ? 0 : ((l / unit) & 1) ^ (r < x.r)) : l < x.l;
    }
} querys[N];
void solve() {
    unit = int(ceil(pow(n, 0.5)));
    sort(querys, querys + m);
    for (int i = 0; i < m; ++i) {
        const node &q = querys[i];
        while (l > q.l) move(--l, 1);
        while (r < q.r) move(++r, 1);
        while (l < q.l) move(l++, -1);
        while (r > q.r) move(r--, -1);
        ans[q.id] = nowAns;
    }
}\end{lstlisting}
\subsubsection{secondary-offline.cpp}
\begin{lstlisting}[language={C++}]
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
inline int rd() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') f ^= (c == '-'), c = getchar();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f ? x : -x;
}
inline void wr(ll x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) wr(x / 10);
    putchar(x % 10 + '0');
}
const int N = 1e5 + 5;
int n, m, a[N], b[N], V, tot;
int st[N], ed[N], pos[N], B;
struct que {
    int l, r, id;
    inline bool operator<(const que &b) const { return (l / tot == b.l / tot) ? r < b.r : l < b.l; }
} q[N];
ll ans[N];
struct ask {
    int id, op, l, r;
    ask() { id = op = l = r = 0; }
    ask(int _id, int _op, int _l, int _r) { id = _id, op = _op, l = _l, r = _r; }
};
ll tr[N];
inline void add(int x, int v) {
    for (; x <= n; x += x & -x) tr[x] += (ll)v;
}
inline ll qry(int x) {
    ll res = 0;
    for (; x; x -= x & -x) res += tr[x];
    return res;
}
int le[N], ri[N];
ll sl[N], sr[N];
vector<ask> v1[N], v2[N];
inline void addl(int pos, int op, int l, int r, int id) { v1[pos].push_back(ask(id, op, l, r)); }
inline void addr(int pos, int op, int l, int r, int id) { v2[pos].push_back(ask(id, op, l, r)); }
ll val[N], tag[N];
inline void updl(int x) {
    if (tag[pos[x]])
        for (int i = st[pos[x]]; i <= ed[pos[x]]; i++) val[i] += tag[pos[x]];
    tag[pos[x]] = 0;
    for (int i = st[pos[x]]; i <= x; i++) val[i]++;
    for (int i = 1; i < pos[x]; i++) tag[i]++;
}
inline void updr(int x) {
    if (tag[pos[x]])
        for (int i = st[pos[x]]; i <= ed[pos[x]]; i++) val[i] += tag[pos[x]];
    tag[pos[x]] = 0;
    for (int i = x; i <= ed[pos[x]]; i++) val[i]++;
    for (int i = pos[x] + 1; i <= B; i++) tag[i]++;
}
signed main() {
    n = rd(), m = rd(), tot = 355, sl[0] = sr[n + 1] = 0;
    for (int i = 1; i <= n; i++) b[i] = a[i] = rd();
    sort(b + 1, b + 1 + n);
    V = unique(b + 1, b + 1 + n) - (b + 1);
    for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + 1 + V, a[i]) - b;
    for (int i = 1; i <= n; i++) le[i] += (i - 1 - qry(a[i])), add(a[i], 1), sl[i] = sl[i - 1] + le[i];
    for (int i = 0; i <= n; i++) tr[i] = 0;
    for (int i = n; i >= 1; i--) ri[i] += qry(a[i] - 1), add(a[i], 1), sr[i] = sr[i + 1] + ri[i];
    for (int i = 1; i <= m; i++) q[i].l = rd(), q[i].r = rd(), q[i].id = i;
    sort(q + 1, q + 1 + m);
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++) {
        if (r < q[i].r) ans[q[i].id] += sl[q[i].r] - sl[r], addl(l, -1, r + 1, q[i].r, q[i].id), r = q[i].r;
        if (r > q[i].r) ans[q[i].id] -= sl[r] - sl[q[i].r], addl(l, 1, q[i].r + 1, r, q[i].id), r = q[i].r;
        if (l < q[i].l) ans[q[i].id] -= sr[l] - sr[q[i].l], addr(r, 1, l, q[i].l - 1, q[i].id), l = q[i].l;
        if (l > q[i].l) ans[q[i].id] += sr[q[i].l] - sr[l], addr(r, -1, q[i].l, l - 1, q[i].id), l = q[i].l;
    }
    B = sqrt(V);
    for (int i = 1; i <= B; i++) st[i] = (i - 1) * B + 1, ed[i] = i * B;
    if (ed[B] < V) ed[B] = V;
    for (int i = 1; i <= B; i++)
        for (int j = st[i]; j <= ed[i]; j++) pos[j] = i;
    for (int i = 1; i <= n; i++) {
        for (ask now : v1[i])
            for (int j = now.l; j <= now.r; j++) ans[now.id] += (ll)now.op * (tag[pos[a[j] + 1]] + val[a[j] + 1]);
        updl(a[i]);
    }
    for (int i = 0; i <= n; i++) tag[i] = val[i] = 0;
    for (int i = n; i >= 1; i--) {
        for (ask now : v2[i])
            for (int j = now.l; j <= now.r; j++) ans[now.id] += (ll)now.op * (tag[pos[a[j] - 1]] + val[a[j] - 1]);
        updr(a[i]);
    }
    for (int i = 1; i <= m; i++) ans[q[i].id] += ans[q[i - 1].id];
    for (int i = 1; i <= m; i++) wr(ans[i]), puts("");
    return 0;
}\end{lstlisting}
\section{odt.cpp}
\begin{lstlisting}[language={C++}]
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <set>
#include <vector>
#define int long long
using namespace std;
const int N = 1e5 + 5, mod = 1e9 + 7;
int n, m, seed, vmax, a[N];
int rnd() {
    int ret = seed;
    seed = (seed * 7 + 13) % mod;
    return ret;
}
int qpow(int a, int b, int Mod) {
    long long res = 1;
    a %= Mod;
    while (b) {
        if (b & 1) res = res * a % Mod;
        a = a * a % Mod, b >>= 1;
    }
    return res;
}
struct node {
    int l, r;
    mutable int v;
    node(const int &ll, const int &rr, const int &vv) : l(ll), r(rr), v(vv) {}
    bool operator<(const node &b) const { return l < b.l; }
};
set<node> st;
typedef set<node>::iterator it;
it split(int x) {
    if (x > n) return st.end();
    it I = st.lower_bound((node){x, 0, 0});
    if (I != st.end() && I->l == x) return I;
    I--;
    if (I->r < x) return st.end();
    int l = I->l, r = I->r, v = I->v;
    st.erase(I);
    st.insert(node(l, x - 1, v));
    return st.insert(node(x, r, v)).first;
}
void assign(int l, int r, int v) {
    it itr = split(r + 1), itl = split(l);
    st.erase(itl, itr);
    st.insert(node(l, r, v));
}
vector<pair<int, int>> tmp;
signed main() {
    cin.tie(0)->sync_with_stdio(false);
    cout.tie(0);
    cin >> n >> m >> seed >> vmax;
    for (int i = 1; i <= n; i++) {
        a[i] = rnd() % vmax + 1;
        st.insert(node(i, i, a[i]));
    }
    for (int at = 1, op, l, r, x, y, ans; at <= m; at++) {
        op = (rnd() % 4) + 1;
        l = (rnd() % n) + 1;
        r = (rnd() % n) + 1;
        if (l > r) swap(l, r);
        if (op == 1) {
            x = rnd() % vmax + 1;
            it itr = split(r + 1), itl = split(l);
            for (; itl != itr; ++itl) itl->v += x;
        } else if (op == 2) {
            x = rnd() % vmax + 1;
            assign(l, r, x);
        } else if (op == 3) {
            x = rnd() % (r - l + 1) + 1;
            tmp.clear();
            it itr = split(r + 1), itl = split(l);
            for (it I = itl; I != itr; ++I) tmp.push_back({I->v, I->r - I->l + 1});
            sort(tmp.begin(), tmp.end());
            ans = -1;
            for (int i = 0; i < tmp.size(); i++) {
                x -= tmp[i].second;
                if (x <= 0) {
                    ans = tmp[i].first;
                    break;
                }
            }
            cout << ans << '\n';
        } else {
            ans = 0;
            x = rnd() % vmax + 1;
            y = rnd() % vmax + 1;
            it itr = split(r + 1), itl = split(l);
            for (it I = itl; I != itr; ++I) ans = (ans + qpow(I->v, x, y) * (I->r - I->l + 1) % y) % y;
            cout << ans << '\n';
        }
    }
    return 0;
}\end{lstlisting}
\end{document}